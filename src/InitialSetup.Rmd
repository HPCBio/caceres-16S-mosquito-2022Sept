```{r, include=FALSE}
# at some point this should be moved into bookdown
source("common_code.R", local = knitr::knit_global())
```

# Setting up the data and project

Code (not shown in the report) is initialized and loaded here.  We don't include the code in the report but make this available as needed; please see the [Github repository](https://github.com/HPCBio/kim-16S-mouse-2022Feb) for this project for the final version.

Data from the primary project folder should be downloaded from [here](https://uofi.box.com/s/4p1tp8tn4o64s5j8ywf9ahi7t3s9qajo) (requires permissions). Note the following assumes all data are in `2022-Feb-16S`.

```{r, echo=FALSE}
library(knitr)
knitr::opts_chunk$set(echo = FALSE, include = TRUE)
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
```

## Import and preprocessing

### Initial file input

There is one run with all of the data.  Load it in along with the relevant tree and sequence data (metadata to be added).

First, let's load in the newer taxonomic analysis using QIIME2.  It looks like this:

```{r}
taxtab <- readRDS('~/research/biotech/young-chae_kim/2021-Fall-Microbiome/results/TADA/R1/Phyloseq/tax_final.md5.R1.RDS')

# this is needed for some downstream steps
taxtab[taxtab == 'Unclassified'] <- NA
knitr::kable(head(taxtab))
```

Object summary:

```{r}
colnames(taxtab) <- c("Domain", "Phylum", "Class", "Order", "Family", "Genus", "Species")
seqtab.tmp <- readRDS('~/research/biotech/young-chae_kim/2021-Fall-Microbiome/results/TADA/R1/Phyloseq/seqtab_final.md5.R1.RDS')
tree.tmp <- read_tree('~/research/biotech/young-chae_kim/2021-Fall-Microbiome/results/TADA/R1/Plain/Trees/rooted.R1.newick')
asvs.tmp <- Biostrings::readDNAStringSet('~/research/biotech/young-chae_kim/2021-Fall-Microbiome/results/TADA/R1/Plain/Sequences/asvs.md5.nochim.R1.fna', format = 'fasta')
physeq <- phyloseq(
  otu_table(seqtab.tmp, taxa_are_rows = F),
  tax_table(taxtab),
  asvs.tmp,
  tree.tmp)

physeq
```

First few sample names to make sure they look like a simple format:

```{r}
head(sample_names(physeq))
```

### Load metadata

Load in experimental data on samples (metadata).  Here are the first few rows:

```{r}
library(readxl)
tmp <- read_tsv('~/research/biotech/young-chae_kim/2021-Fall-Microbiome/Metadata/Metadata.txt')
tmp$Strain <- factor(tmp$Strain)
tmp$Sex <- factor(tmp$Sex)
tmp$Replicate <- factor(tmp$Replicate)

knitr::kable(head(tmp))
```

We also read in read QC so we can layer in whether read abundance plays a role.  We need to do a bit of our own read tracking here (it's not currently in the pipeline but can be added).

```{r results="asis"}
track <- read_tsv("~/research/biotech/young-chae_kim/2021-Fall-Microbiome/results/TADA/Plain/QC/all.readtracking.R1.txt")
knitr::kable(track)
```

We see a fairly substantial drop from merging; we can possibly use just R1, but let's proceed with this first.

Combine all metadata together for analysis and add back to the class.

```{r, include=FALSE}
tmp2 <- sample_data(right_join(tmp, track, by="SampleID"))
sample_names(tmp2) <- tmp2$Sample
sample_names(tmp2)
```

Here is the sample object summary now:

```{r}
sample_data(physeq) <- tmp2
physeq
```

What do the first rows look like?

```{r results="asis"}
sample_data(physeq) %>% as("data.frame") %>% head %>% knitr::kable()
```

## Raw composition plots

Overall compositional summary (stacked bar plots) for samples.  In this example here are the top 15 families by composition per sample, split by treatment.  We can generate a publication-quality plot depending on your need.

```{r, results='asis', fig.keep='all', message = FALSE, warning = FALSE, echo = FALSE}
ranks <- c("Class", "Order", "Family", "Genus", "Species")
plots <- lapply(ranks, function (x) { ggplotly(phyloseq.extended::plot_composition(physeq,
                                         taxaSet1 = NULL, 
                                         taxaRank2 = x, 
                                         fill = x, 
                                         numberOfTaxa = 15))} )

names(plots) <- ranks
# Build list of outputs
# See https://stackoverflow.com/questions/9469504/access-and-preserve-list-names-in-lapply-function for example

# not sure if there is an easy way to make a function out of these.
output <- list()
for(rank in ranks){
  # Header for iteration, note Rmd heading ranks and adjust accordingly
  output[[length(output) + 1L]] <- paste0("### ", rank)

  # Plot
  output[[length(output) + 1L]] <- plots[[rank]]
}

# Render the outputs
for(j in 1:length(output)){
  x <- output[[j]]

  if(inherits(x, "character")){
    cat("\n")
    cat(x)
  } else if(inherits(x, "knitr_kable")){
    cat("\n")
    print(x)
  }
  else {
    # print the html piece of the htmlwidgets
    cat("\n")
    cat(htmltools::renderTags(as_widget(x))$html)
  }
}
```

```{r echo=FALSE, messages=FALSE, warning=FALSE}
# Attach the Dependencies since they do not get included with renderTags(...)$html
deps <- lapply(
  Filter(f = function(x){inherits(x,"htmlwidget")}, x = output),
  function(hw){
    htmltools::renderTags(hw)$dependencies
  }
)
htmltools::attachDependencies(x = htmltools::tagList(), value = unlist(deps,recursive=FALSE))
```

## Save file

```{r}
saveRDS(physeq, 
        '~/research/biotech/young-chae_kim/2021-Fall-Microbiome/results/physeq.raw.RDS')
```
